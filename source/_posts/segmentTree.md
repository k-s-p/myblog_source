---
title: segmentTree
date: 2024-03-07 20:42:27
tags:
---

# セグメント木を理解を理解したい

最近のABCではセグメント木の問題が多いですね、、、
そろそろライブラリとして持っておいた方がいいと思い勉強したのでまとめて行きたいと思います。

## セグメント木とはなんなのか？

とりあえず、セグメント木とはいったい何でどんなことができるのか探るためにGPT君に聞いてみた結果、以下の回答が得られました。

> セグメント木とは、完全二分木（全ての葉の深さが等しい木）によって実装された、区間を扱うのに適したデータ構造のことです。このデータ構造の特徴は、区間に対する操作を対数時間$O(logn)$で行えることで、競技プログラミングなどで頻出となっています。
>
>セグメント木でできることは以下の通りです：
> - 区間の集計：例えば、ある配列に対する区間の最小値や総和などを高速に計算できます。
> - 配列の値の更新：配列の特定の要素の値を更新し、それに伴う区間の集計結果を高速に再計算できます。
> 
>これらの操作は、セグメント木の構造（完全二分木）と、それぞれのノードが一つの区間を表現しているという性質により、効率的に行うことができます。ただし、セグメント木で扱える操作は、その操作が結合法則を満たすものに限られます。例えば、区間の2乗和を直接計算することはできません。これは、2乗和が結合法則を満たさないためです。

つまり、**セグメント木とは完全二分木で、区間の集計や値の更新を$を高速に行えるとても便利なデータ構造だということがわかりました。** ただし、結合法則を満たさないので区間の2乗和を**直接**計算することはできないようです(2乗した値を配列にいれて区間和を計算することで実現可能)。

### セグメント木で扱える値とは

セグメント木で扱えるデータは、**単位元**と**二項演算**を定義した値(モノイド)です。
モノイドというものの詳細はまだよくわかってないのでここでは書けませんが、セグメント木を使って簡単な問題を解くために覚えておいた方がいいことは以下の二点です。
- **結合法則を満たす**：任意の区間に含まれる値の集約結果が一意となるために必要
    <br>$x_1,x_2,x_3,x_4$という値が区間に含まれているときにその区間の和を求めたい場合、$(x_1+x_2)+(x_3+x_4)$と計算する場合や、$x_1+(x_2+x_3)+x_4$と計算する場合などがあり、どの計算でも結果が変わらないようにする必要がある
- **単位元と二項演算を定義する**: 求めたい結果によって二項演算を定義する。単位元は二項演算の結果に影響を与えない値を定義し、初期化時などに空いている葉を埋めるために利用する。
  - 加算結果を求めたい場合は単位元:$0$、二項演算:$+$。
  - 最小値を求めたい場合は単位元:$\infty$、二項演算:$min()$など

### セグメント木の構造について

セグメント木は以下のような形の完全二分木となっています。数字はインデックスを表しています。

![セグメント木の構造](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree1.png)

ノードの数は、元のデータ数以上になる最小の2のべき乗の数を$N$としたときに、全部で$2N-1$個あります。
つまり、一番下の段にはノードが$N$個あり、それより上の段のノードは全部で$N-1$個になります。<br>
ある$k$番目のノードから自分の親・子にアクセスするには
- 親：$\lfloor \frac{k}{2} \rfloor$番目にアクセスする
- 子：$2k$, $2k+1$番目にアクセスする

### セグメント木の動作を理解する

例として、区間の和を求めるセグメント木を用いてセグメント木がどのように動作するか見てみます。<br>
$A[4,3,5,6,3,8,1,2]$がありこの配列の区間和を求めたいとします。<br>

#### 初期化
セグメント木のサイズは$2N-1$となるため、この配列の場合は15になります。
そして、最下段に区間を求める元の配列Aの値を持つようにすると以下のようになります。

![初期化](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree2.png)

ここから、**下から上に向かって**値の更新を行っていきます。
一つ上の段を更新すると以下のようになります。このように、親ノードは子の和をもっています。
![二段目を更新](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree3.png)

これを一番上まで行うと以下のようになり、セグメント木の構築が完了しました。
![セグメント木の構築完了](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree4.png)

### 区間の値を取得

例えば、区間$\lbrack 1, 7 )$の総和を求めたいとします。
この時、$A[1]+A[2]+A[3]+A[4]+A[5]+A[6]$を行って求めることができますが、そのような求め方は効率が悪いため、もっと良い方法で求めたいです。
セグメント木の構築結果を見るとすでに計算された区間を含んでいるため、以下の黄色のノードを選択すれば求められることがわかります。
![区間の値を取得](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree5.png)

### 値の更新

例えば、A[4]の値を100に更新したとすると、更新された値が親のほうへ順に伝わっていきます。
![値の更新](https://cdn.jsdelivr.net/gh/k-s-p/cdn/img/segTree6.png)

## セグメント木を実装する(非再帰)
それでは、区間和を求めるセグメント木をpythonで実装したいと思います。実装では木を1-indexedで実装しています。

### 初期化
区間和を求めるセグメント木の二項演算は$+$,単位元は$0$となるため、以下の以下のように設定します。

```python
# 二項演算
def operation(x,y):
    return x+y

# 単位元
identity = 0
```

次に、リストAの長さNをもとにノードの数を求める。最下段のノードの数は元の配列のサイズ以上になる最小の2冪の数であり、これを**size**すると、木全体で必要なノード数は$2*size-1$となる。ただし、1-indexedで実装しているため、2*size個のノードとなっていることに注意。<br>
初期値は$\lbrack size, 2*size )$に当てはめていく。<br>
そして、最下段から根まで値を更新していく。更新は、親が子に対して二項演算を行うことで実現できる。<br>
実装は以下のコードとなります。計算量は$O(NlogN)$です。
```python
class SegTree():
    
    def __init__(self, default_values, operation, identity):
        """
        セグメント木の初期化を行う
        default_values: セグメント木を初期化する配列
        operation: 二項演算 
        identity: 単位元
        self.size: n以上で最小の2冪の整数
        """
        self.size = 1
        self.op = operation
        self.identity = identity
        n = len(default_values)
        while self.size < n:
            self.size *= 2
        self.tree = [identity] * (self.size * 2)
        #　初期値を葉にセット
        for i in range(n):
            self.tree[self.size + i] = default_values[i]
        # 根に向かって値を更新していく
        for i in range(self.size -1, 0, -1):
            self.tree[i] = self.op(self.tree[i*2], self.tree[i*2 + 1])
```

### 値の更新

ノードの更新処理を実装します。ここでは、A[pos]の値をxに更新します。
セグメント木のノードでは**pos+size**の値を更新すればいいです。その後は、木を上に辿りながら、値を更新していきます。

```python
def update(self, pos, x): 
        """
        セグメント木のpos番目の値をxに置き換える
        その後、セグメント木の根に向かって更新する
        """
        pos += self.size # 入力されるposは0-indexedなので、A[pos]に対応するセルの番号はpos + size
        self.tree[pos] = x
        while pos >= 2:
            pos >>= 1 # 1bit右にシフト(2で割る)
            self.tree[pos] = self.op(self.tree[pos*2], self.tree[pos*2 + 1]) # セグメント木の更新
```

### 区間和取得

ここでは、区間$\lbrack l,r )$の計算結果を求める処理を実装します。前述の図のような効率のいいノードの選択は$l$と$r$のノードがそれぞれ**左の子**か**右の子**かを見ることで決定できます。ここで、子が左の子の場合はindexが偶数、右の子の場合はindexが奇数です。<br>
区間の左側のノードに対しては以下のような条件分岐が考えられます。
- 右の子の場合、このノードの親は左側の兄弟も含んでいるため親を選択するべきではない。よって、自分を選択し、右隣のノードに移動する
- 左の子の場合、このノードの親は自分と自分の一つ右の兄弟の情報を含んでいるのでこのノードの親を選択する

区間の右側のノードについては、左側と逆の条件分岐となります。
- 右の子の場合、このノードの親は自分と一つ左の兄弟の情報を含んでいるのでこのノードの親を選択する
- 左の子の場合、このノードの親は自分とその右側の兄弟の情報を含んでいるため親を選択するべきではない。よって、自分を選択し、左隣のノードに移動する

上記の操作を行いながら、親へと移動していくと、最終的に指定した区間の総和を求めることができます。ただし、半開区間なので、実装では右側のノードの判定は逆転しています。

```python
def query(self,l, r):
        """
        半開区間[l, r)の区間の結果を求める
        あるノードが区間[l, r)に含まれていて、親ノードの区間が左方向にはみ出すとき、そのノードは右側の子(奇数)
        逆に親ノードが右側にはみ出すとき、そのノードは左側の子(偶数)
        木を下から上って、左側は親の区間がはみ出すなら、そのノードの値に対象の操作を行い、インデックスを1つ右にずらす
        右側は親の区間がはみ出すなら、そのノードの値に対象の操作を行い、インデックスを1つ左にずらす
        ただし、右側は半開区間なので、奇数かどうかを判断することになる
        """
        # l, rをA[l],A[r]に対応させる
        l += self.size
        r += self.size

        lres,rres = self.identity, self.identity # 左右の答えを初期化
        #l,rが重なるまで判定を繰り返す
        while l < r:
            # lが奇数なら、lの親は左側にはみだす
            if l & 1:
                lres = self.op(lres, self.tree[l])
                l += 1
            # 半開区間のため、rが奇数ならr-1の親が右にはみ出しているということ
            if r & 1:
                r -= 1
                rres = self.op(rres, self.tree[r])
            
            # 木を上にのぼる
            l >>= 1
            r >>= 1
        res = self.op(lres, rres)
        return res
```

## 完了
これでセグメント木が構築できました！
あとは、二項演算と単位元を変えることで様々な演算に対応することができます。
最後に完成したコードを載せておきます。実際にライブラリとして使ってますので、バグや実装の改善点があれば教えていただけると助かります！

```python
# セグメント木でやりたい操作に応じて、opと答えの初期値を作る
# # 最小値
# def op(x,y):
#     return min(x,y)
# i_e = float('Inf')

# 最大値
# def op(x,y):
#     return max(x,y)
# i_e = -float('Inf')

# 区間の和
def op(x,y):
    return x+y
i_e = 0

# # 区間の積
# def op(x,y):
#     return x*y
# i_e = 1

# # 最大公約数
# import math
# def op(x,y):
#     return math.gcd(x,y)
# i_e = 0

# 木自体は1-indexedで作成される
class SegTree():
    
    def __init__(self, default_values, operation, identity):
        """
        セグメント木の初期化を行う
        default_values: セグメント木を初期化する配列
        operation: 二項演算 
        identity: 単位元
        self.size: n以上で最小の2^k乗の整数
        """
        self.size = 1
        self.op = operation
        self.identity = identity
        n = len(default_values)
        while self.size < n:
            self.size *= 2
        self.tree = [identity] * (self.size * 2)
        #　初期値を葉にセットしていく
        for i, value in enumerate(default_values):
            self.tree[self.size + i] = value
        # セグメント木を作成していく
        for i in range(self.size -1, 0, -1):
            self.tree[i] = self.op(self.tree[i*2], self.tree[i*2 + 1])

    def update(self, pos, x): 
        """
        セグメント木のpos番目の値をxに置き換える
        その後、セグメント木の根に向かって更新する
        """
        pos += self.size # 入力されるposは0-indexedなので、A[pos]に対応するセルの番号はpos + size
        self.tree[pos] = x
        while pos >= 2:
            pos >>= 1 # 1bit右にシフト(2で割る)
            self.tree[pos] = self.op(self.tree[pos*2], self.tree[pos*2 + 1]) # セグメント木の更新
    
    def query(self,l, r):
        """
        半開区間[l, r)の区間の結果を求める
        あるノードが区間[l, r)に含まれていて、親ノードの区間が左方向にはみ出すとき、そのノードは右側の子(奇数)
        逆に親ノードが右側にはみ出すとき、そのノードは左側の子(偶数)
        木を下から上って、左側は親の区間がはみ出すなら、そのノードの値に対象の操作を行い、インデックスを1つ右にずらす
        右側は親の区間がはみ出すなら、そのノードの値に対象の操作を行い、インデックスを1つ左にずらす
        ただし、右側は半開区間なので、奇数かどうかを判断することになる
        """
        # l, rをA[l],A[r]に対応させる
        l += self.size
        r += self.size

        lres,rres = self.identity, self.identity # 左右の答えを初期化
        #l,rが重なるまで判定を繰り返す
        while l < r:
            # lが奇数なら、lの親は左側にはみだす
            if l & 1:
                lres = self.op(lres, self.tree[l])
                l += 1
            # 半開区間のため、rが奇数ならr-1の親が右にはみ出しているということ
            if r & 1:
                r -= 1
                rres = self.op(rres, self.tree[r])
            
            # 木を上にのぼる
            l >>= 1
            r >>= 1
        res = self.op(lres, rres)
        return res
    
A = [4,3,5,6,3,8,1,2]
segtree = SegTree(A, op, i_e)
print(segtree.query(0, 8))
segtree.update(4, 100)
print(segtree.query(0,8))
```